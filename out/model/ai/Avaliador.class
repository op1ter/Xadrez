package model.ai;

import model.board.Board;
import model.board.Move;

public interface ChessAI {
    Move fazerJogada(Board tabuleiro, char corJogador);
}

public class Avaliador {
    public static int avaliar(Board board) {
        int pontuacao = 0;
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                char peca = board.getPieceAt(i, j);
                if (peca != ' ') {
                    int valor = valorPeca(peca);
                    pontuacao += Character.isUpperCase(peca) ? valor : -valor;
                }
            }
        }
        return pontuacao;
    }

    private static int valorPeca(char peca) {
        switch (Character.toLowerCase(peca)) {
            case 'p': return 100;
            case 'c': return 320;
            case 'b': return 330;
            case 't': return 500;
            case 'd': return 900;
            case 'r': return 20000;
            default: return 0;
        }
    }
}

package model.ai;

import model.board.Board;
import model.board.Move;
import java.util.List;

public class IANivel3 implements ChessAI {
    private static final int PROFUNDIDADE_MAXIMA = 3;

    @Override
    public Move fazerJogada(Board tabuleiro, char corJogador) {
        List<Move> movimentosValidos = tabuleiro.getAllValidMoves(corJogador);

        Move melhorMovimento = null;
        int melhorAvaliacao = corJogador == 'B' ? Integer.MIN_VALUE : Integer.MAX_VALUE;

        for (Move movimento : movimentosValidos) {
            Board copia = tabuleiro.clone();
            copia.makeMove(movimento);

            int avaliacao = minimax(copia, PROFUNDIDADE_MAXIMA - 1,
                    (corJogador == 'B') ? 'P' : 'B',
                    Integer.MIN_VALUE, Integer.MAX_VALUE);

            if ((corJogador == 'B' && avaliacao > melhorAvaliacao) ||
                (corJogador == 'P' && avaliacao < melhorAvaliacao)) {
                melhorAvaliacao = avaliacao;
                melhorMovimento = movimento;
            }
        }

        return melhorMovimento;
    }

    private int minimax(Board tabuleiro, int profundidade, char jogadorAtual, int alfa, int beta) {
        if (profundidade == 0) {
            return Avaliador.avaliar(tabuleiro);
        }

        List<Move> movimentos = tabuleiro.getAllValidMoves(jogadorAtual);
        if (movimentos.isEmpty()) {
            return Avaliador.avaliar(tabuleiro);
        }

        if (jogadorAtual == 'B') {
            int valorMax = Integer.MIN_VALUE;
            for (Move movimento : movimentos) {
                Board copia = tabuleiro.clone();
                copia.makeMove(movimento);
                int valor = minimax(copia, profundidade - 1, 'P', alfa, beta);
                valorMax = Math.max(valorMax, valor);
                alfa = Math.max(alfa, valorMax);
                if (beta <= alfa) break;
            }
            return valorMax;
        } else {
            int valorMin = Integer.MAX_VALUE;
            for (Move movimento : movimentos) {
                Board copia = tabuleiro.clone();
                copia.makeMove(movimento);
                int valor = minimax(copia, profundidade - 1, 'B', alfa, beta);
                valorMin = Math.min(valorMin, valor);
                beta = Math.min(beta, valorMin);
                if (beta <= alfa) break;
            }
            return valorMin;
        }
    }
}
